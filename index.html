<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PMP + Agile Hangman ‚Äî Project Health</title>
  <style>
    :root{
      /* Professional palette: slate + emerald/teal + amber + red (no blue) */
      --bg:#0a0f16;
      --card:#0f1722;
      --card2:#0b1320;
      --text:#e7eaf0;
      --muted:#9aa6b2;
      --border:rgba(154,166,178,0.18);

      --accent:#10b981;   /* emerald */
      --accent2:#14b8a6;  /* teal */
      --good:#22c55e;
      --warn:#f59e0b;
      --bad:#ef4444;

      --radius:18px;
      --shadow: 0 18px 45px rgba(0,0,0,0.38);
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background:
        radial-gradient(circle at 18% 12%, rgba(16,185,129,0.16), transparent 42%),
        radial-gradient(circle at 82% 22%, rgba(20,184,166,0.10), transparent 45%),
        radial-gradient(circle at 55% 95%, rgba(245,158,11,0.10), transparent 50%),
        var(--bg);
      color:var(--text);
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:24px;
    }

    .wrap{width:min(1060px, 100%); display:grid; gap:14px;}
    .top{
      display:flex; flex-wrap:wrap; gap:12px;
      align-items:flex-end; justify-content:space-between;
    }
    h1{margin:0; letter-spacing:-0.02em; font-size: clamp(20px, 2.4vw, 30px);}
    .sub{color:var(--muted); margin-top:6px; line-height:1.35; font-size: 13px;}

    .pill{
      padding:10px 12px; border-radius:999px;
      border:1px solid var(--border);
      background: rgba(15,23,34,0.78);
      box-shadow: var(--shadow);
      font-size: 12px; color: var(--muted);
      display:flex; gap:12px; align-items:center;
      white-space:nowrap;
    }
    .pill b{color:var(--text)}
    .pill .dot{
      width:10px; height:10px; border-radius:999px;
      background: linear-gradient(135deg, rgba(16,185,129,1), rgba(20,184,166,1));
      box-shadow: 0 0 18px rgba(16,185,129,0.25);
    }

    .grid{
      display:grid;
      grid-template-columns: 1.15fr 0.85fr;
      gap:14px;
    }
    .card{
      background: linear-gradient(180deg, rgba(15,23,34,0.90), rgba(11,19,32,0.90));
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding:16px;
    }
    .card h2{
      margin:0 0 10px 0;
      font-size: 12px;
      letter-spacing:0.12em;
      text-transform: uppercase;
      color: var(--muted);
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
    }

    .controls{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      margin-bottom: 10px;
    }
    .controlGroup{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    }
    .control{
      display:flex; gap:8px; align-items:center;
      padding: 9px 10px;
      border-radius: 14px;
      border:1px solid rgba(154,166,178,0.20);
      background: rgba(2,6,23,0.18);
    }
    .control label{
      font-size: 12px;
      color: var(--muted);
      font-weight: 800;
      letter-spacing: 0.04em;
    }
    select{
      background: transparent;
      color: var(--text);
      border: none;
      outline: none;
      font-weight: 850;
      font-size: 12px;
      letter-spacing: 0.02em;
      cursor: pointer;
    }
    select option{ background: #0b1320; color: var(--text); }
    .toggle{
      display:flex; gap:10px; align-items:center;
      cursor:pointer;
      user-select:none;
    }
    .toggle input{ display:none; }
    .switch{
      width: 44px; height: 26px;
      background: rgba(154,166,178,0.22);
      border: 1px solid rgba(154,166,178,0.22);
      border-radius: 999px;
      position: relative;
      transition: all .18s ease;
    }
    .knob{
      width: 20px; height: 20px;
      border-radius: 999px;
      background: rgba(231,234,240,0.92);
      position:absolute;
      top: 2px; left: 2px;
      transition: all .18s ease;
      box-shadow: 0 8px 20px rgba(0,0,0,0.35);
    }
    .toggle input:checked + .switch{
      background: rgba(16,185,129,0.25);
      border-color: rgba(16,185,129,0.35);
      box-shadow: 0 0 0 4px rgba(16,185,129,0.08);
    }
    .toggle input:checked + .switch .knob{
      left: 22px;
      background: rgba(231,234,240,0.95);
    }
    .toggleText{
      font-size: 12px;
      color: var(--muted);
      font-weight: 900;
      letter-spacing: 0.04em;
    }

    /* Word board */
    .word{
      display:flex; flex-wrap:wrap; gap:10px 12px;
      padding: 6px 2px 14px;
      align-items:center;
      min-height: 64px;
    }
    .tile{
      width: 34px; height: 44px;
      display:flex; align-items:center; justify-content:center;
      border-radius: 12px;
      border:1px solid rgba(154,166,178,0.22);
      background: rgba(2,6,23,0.22);
      font-size: 20px;
      font-weight: 900;
      letter-spacing: 0.02em;
    }
    .tile.space{
      width: 14px; height: 44px;
      border: none; background: transparent;
    }
    .tile.punct{
      width: 22px; border:none; background: transparent;
      color: var(--muted);
    }

    .actions{
      display:flex; flex-wrap:wrap; gap:10px;
      align-items:center; justify-content:space-between;
      margin-top: 6px;
    }
    button{
      cursor:pointer;
      border: 1px solid rgba(154,166,178,0.22);
      background: rgba(15,23,34,0.80);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      font-weight: 900;
      font-size: 13px;
      letter-spacing: 0.01em;
      transition: transform .08s ease, border-color .14s ease, background .14s ease;
    }
    button:hover{
      border-color: rgba(16,185,129,0.45);
      background: rgba(15,23,34,0.92);
    }
    button:active{ transform: translateY(1px); }
    button:disabled{ opacity:0.45; cursor:not-allowed; }

    .btnPrimary{
      border-color: rgba(16,185,129,0.35);
      background: rgba(16,185,129,0.12);
    }
    .btnPrimary:hover{
      border-color: rgba(16,185,129,0.55);
      background: rgba(16,185,129,0.16);
    }
    .btnGhost{
      background: rgba(2,6,23,0.12);
    }
    .btnDanger{
      border-color: rgba(239,68,68,0.35);
      background: rgba(239,68,68,0.10);
    }
    .btnDanger:hover{
      border-color: rgba(239,68,68,0.55);
      background: rgba(239,68,68,0.14);
    }

    .hint{
      margin-top: 10px;
      padding: 12px;
      border-radius: 14px;
      background: rgba(2,6,23,0.20);
      border: 1px dashed rgba(154,166,178,0.22);
      color: var(--muted);
      line-height: 1.4;
      font-size: 13px;
      display:none;
    }

    /* Keyboard */
    .kbd{
      display:grid;
      grid-template-columns: repeat(13, 1fr);
      gap:8px;
    }
    .key{
      border:1px solid rgba(154,166,178,0.18);
      background: rgba(2,6,23,0.18);
      border-radius: 12px;
      padding: 10px 0;
      text-align:center;
      font-weight: 950;
      font-size: 13px;
      user-select:none;
      cursor:pointer;
      color: var(--text);
      transition: border-color .14s ease, transform .08s ease, background .14s ease;
    }
    .key:hover{
      border-color: rgba(16,185,129,0.40);
      transform: translateY(-1px);
    }
    .key.used{ opacity:0.35; cursor:not-allowed; transform:none !important; }
    .key.good{
      border-color: rgba(34,197,94,0.55);
      background: rgba(34,197,94,0.10);
    }
    .key.bad{
      border-color: rgba(239,68,68,0.55);
      background: rgba(239,68,68,0.10);
    }

    /* Health meter */
    .meterWrap{ display:grid; gap:12px; }
    .meter{
      border:1px solid var(--border);
      border-radius: 16px;
      padding: 12px;
      background: rgba(2,6,23,0.18);
    }
    .meterTop{ display:flex; justify-content:space-between; align-items:center; gap:10px; }
    .meterTop .label{ color: var(--muted); font-size: 12px; font-weight: 900; letter-spacing:0.10em; text-transform:uppercase; }
    .meterTop .state{ font-weight: 950; }
    .bar{
      height: 12px;
      border-radius: 999px;
      background: rgba(154,166,178,0.18);
      overflow:hidden;
      margin-top: 10px;
    }
    .fill{
      height:100%;
      width: 100%;
      background: linear-gradient(90deg, rgba(34,197,94,0.95), rgba(16,185,129,0.90));
      border-radius: 999px;
      transition: width .18s ease;
    }

    .statRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .stat{
      border:1px solid var(--border);
      border-radius: 16px;
      padding: 12px;
      background: rgba(2,6,23,0.16);
    }
    .stat .k{
      color: var(--muted);
      font-size: 12px;
      font-weight: 900;
      letter-spacing:0.10em;
      text-transform:uppercase;
      display:flex; justify-content:space-between; gap:10px;
    }
    .stat .v{ font-size: 22px; font-weight: 950; margin-top:6px; }

    .toast{
      margin-top: 10px;
      padding: 12px;
      border-radius: 14px;
      border: 1px solid rgba(154,166,178,0.20);
      background: rgba(15,23,34,0.72);
      color: var(--text);
      line-height: 1.35;
      font-size: 13px;
      display:none;
    }
    .toast.good{ border-color: rgba(34,197,94,0.35); }
    .toast.bad{ border-color: rgba(239,68,68,0.35); }

    .smallNote{ color: var(--muted); font-size: 12px; line-height:1.4; }

    @media (max-width: 980px){
      .grid{ grid-template-columns: 1fr; }
      .kbd{ grid-template-columns: repeat(10, 1fr); }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div>
        <h1>PMP + Agile Hangman <span style="color:var(--accent)">‚Äî Project Health</span></h1>
        <div class="sub">Practice mode or Exam mode ‚Ä¢ 1000-term bank ‚Ä¢ No repeats per user until exhausted</div>
      </div>
      <div class="pill">
        <span class="dot"></span>
        <span>Best Streak: <b id="bestStreak">0</b></span>
        <span>Current Streak: <b id="streak">0</b></span>
      </div>
    </div>

    <div class="grid">
      <!-- Left: game -->
      <div class="card">
        <h2>
          <span>Guess the term</span>
          <span class="smallNote" id="bankStatus">Loading bank‚Ä¶</span>
        </h2>

        <div class="controls">
          <div class="controlGroup">
            <div class="control">
              <label for="diffSelect">Difficulty</label>
              <select id="diffSelect" title="Filter the word deck by difficulty">
                <option value="all">Balanced</option>
                <option value="easy">Easy</option>
                <option value="medium">Medium</option>
                <option value="hard">Hard</option>
              </select>
            </div>

            <div class="control">
              <div class="toggle" title="Toggle Exam mode (10 rounds)">
                <label class="toggle" style="gap:10px;">
                  <input id="examToggle" type="checkbox" />
                  <span class="switch"><span class="knob"></span></span>
                  <span class="toggleText" id="modeLabel">Practice</span>
                </label>
              </div>
            </div>

            <div class="control">
              <label>Remaining</label>
              <div style="font-weight:950; font-size:12px;" id="remaining">‚Äî</div>
            </div>
          </div>

          <div class="controlGroup">
            <button id="btnShare" class="btnGhost" title="Copy a shareable score blurb">Share</button>
            <button id="btnResetDeck" class="btnDanger" title="Reset the no-repeat deck (this device/browser)">Reset Deck</button>
          </div>
        </div>

        <div class="word" id="word"></div>

        <div class="actions">
          <div style="display:flex; gap:10px; flex-wrap:wrap;">
            <button id="btnHint" class="btnGhost">Show hint</button>
            <button id="btnNext" class="btnPrimary">New word</button>
          </div>
          <div style="color:var(--muted); font-size:12px;">
            Wrong guesses left: <b id="lives">6</b>
            <span id="examProgress" style="margin-left:10px; display:none;">‚Ä¢ Round <b id="roundNow">1</b>/<b id="roundTotal">10</b></span>
          </div>
        </div>

        <div class="hint" id="hint"></div>
        <div class="toast" id="toast"></div>

        <div style="height:12px;"></div>
        <h2>Keyboard <span class="smallNote">Tip: You can type on your keyboard too</span></h2>
        <div class="kbd" id="kbd"></div>
      </div>

      <!-- Right: status -->
      <div class="card">
        <h2>Project health</h2>
        <div class="meterWrap">
          <div class="meter">
            <div class="meterTop">
              <div class="label">Health meter</div>
              <div class="state" id="stateText">On Track</div>
            </div>
            <div class="bar"><div class="fill" id="fill"></div></div>
            <div class="smallNote" style="margin-top:10px;">
              Wrong guesses reduce health. Solve the term to keep the project green.
            </div>
          </div>

          <div class="statRow">
            <div class="stat">
              <div class="k"><span>Score</span><span id="scoreTag" style="opacity:.9;">Practice</span></div>
              <div class="v" id="score">0</div>
            </div>
            <div class="stat">
              <div class="k">Solved</div>
              <div class="v" id="solved">0</div>
            </div>
          </div>

          <div class="stat" style="grid-column: 1 / -1;">
            <div class="k"><span>Mode</span><span id="modeHint" style="opacity:.9;">No-repeat deck per device</span></div>
            <div class="v" style="font-size:16px; margin-top:10px;" id="modeDetail">Practice ‚Ä¢ Balanced</div>
            <div class="smallNote" style="margin-top:8px;">
              Spaces/hyphens/slashes show automatically. Hint is available once per round.
            </div>
          </div>

          <div class="stat" style="grid-column: 1 / -1;">
            <div class="k"><span>Exam mode</span><span style="opacity:.9;">10 rounds</span></div>
            <div class="smallNote" style="margin-top:8px;">
              Turn Exam ON to run a 10-round session. Your exam score is computed the same way as practice.
              At the end, you'll get a summary and a share-ready message.
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
  // =============================
  // Configuration
  // =============================
  const MAX_LIVES = 6;
  const EXAM_ROUNDS = 10;

  // Word bank loaded from words.json
  let BANK = [];
  let BANK_SIG = "";

  // Difficulty buckets
  const DIFFS = ["all","easy","medium","hard"];
  const subsetIndices = { all: [], easy: [], medium: [], hard: [] };

  // IMPORTANT CHANGE:
  // Decks are now IN-MEMORY (not saved to localStorage), so every fresh page load starts at 1000 again.
  // This matches: "each time someone opens the link, start fresh".
  const decks = { all: [], easy: [], medium: [], hard: [] };

  // Still OK to persist best streak for the same device (optional)
  const LS_BEST_STREAK = "pmpHangmanBestStreak_v4";

  // =============================
  // UI elements
  // =============================
  const wordEl = document.getElementById("word");
  const kbdEl = document.getElementById("kbd");
  const hintEl = document.getElementById("hint");
  const btnHint = document.getElementById("btnHint");
  const btnNext = document.getElementById("btnNext");
  const btnShare = document.getElementById("btnShare");
  const btnResetDeck = document.getElementById("btnResetDeck");
  const livesEl = document.getElementById("lives");
  const fillEl = document.getElementById("fill");
  const stateText = document.getElementById("stateText");
  const scoreEl = document.getElementById("score");
  const solvedEl = document.getElementById("solved");
  const streakEl = document.getElementById("streak");
  const bestStreakEl = document.getElementById("bestStreak");
  const toastEl = document.getElementById("toast");
  const bankStatusEl = document.getElementById("bankStatus");
  const diffSelect = document.getElementById("diffSelect");
  const examToggle = document.getElementById("examToggle");
  const modeLabel = document.getElementById("modeLabel");
  const remainingEl = document.getElementById("remaining");
  const modeDetailEl = document.getElementById("modeDetail");
  const scoreTagEl = document.getElementById("scoreTag");

  const examProgress = document.getElementById("examProgress");
  const roundNowEl = document.getElementById("roundNow");
  const roundTotalEl = document.getElementById("roundTotal");

  // =============================
  // Game state
  // =============================
  const ALPH = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
  let used = new Set();
  let revealed = new Set();
  let answer = "";
  let currentPick = null;

  let lives = MAX_LIVES;
  let score = 0;
  let solvedCount = 0;

  let streak = 0;
  let bestStreak = Number(localStorage.getItem(LS_BEST_STREAK) || 0);

  // Exam state
  let examActive = false;
  let examRound = 0;       // 1..EXAM_ROUNDS
  let examSolved = 0;
  let examFailed = 0;
  let examScore = 0;

  // Round state
  let guessesMade = false;     // NEW: used to lock difficulty only AFTER first guess
  let roundInPlay = false;

  bestStreakEl.textContent = bestStreak;
  roundTotalEl.textContent = String(EXAM_ROUNDS);

  // =============================
  // Utilities
  // =============================
  function showToast(text, type){
    toastEl.textContent = text;
    toastEl.className = "toast " + (type || "");
    toastEl.style.display = "block";
  }
  function hideToast(){ toastEl.style.display = "none"; }

  function setHint(text){
    hintEl.textContent = text || "";
    hintEl.style.display = text ? "block" : "none";
  }

  function difficultyLabel(d){
    if (d === "all") return "Balanced";
    return d.charAt(0).toUpperCase() + d.slice(1);
  }

  function classifyDifficulty(term){
    // Lightweight heuristic: length + number of words + punctuation/rare letters
    const t = (term || "").toUpperCase().trim();
    const lettersOnly = t.replace(/[^A-Z]/g,"");
    const charLen = lettersOnly.length;
    const wordCount = t.split(/\s+/).filter(Boolean).length;
    const hasPunct = /[^A-Z\s]/.test(t);
    const rare = (lettersOnly.match(/[JQXZ]/g) || []).length;

    let s = 0;
    if (charLen <= 10) s += 0;
    else if (charLen <= 18) s += 1;
    else s += 2;

    if (wordCount <= 2) s += 0;
    else if (wordCount <= 3) s += 1;
    else s += 2;

    if (hasPunct) s += 1;
    if (rare >= 2) s += 1;

    if (s <= 1) return "easy";
    if (s <= 3) return "medium";
    return "hard";
  }

  function bankSignature(){
    return String(BANK.length) + ":" + DIFFS.map(d => subsetIndices[d].length).join(",");
  }

  function shuffle(arr){
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  // =============================
  // Deck logic (NO repeats within a session; resets on page reload)
  // =============================
  function buildFreshDeck(diff){
    const base = subsetIndices[diff] || [];
    decks[diff] = shuffle(base.slice());
    return decks[diff];
  }

  function getDeck(diff){
    if (!decks[diff] || decks[diff].length === 0){
      return buildFreshDeck(diff);
    }
    return decks[diff];
  }

  function remainingCount(diff){
    return (decks[diff] && decks[diff].length) ? decks[diff].length : (subsetIndices[diff] || []).length;
  }

  function drawNextPick(diff){
    let deck = getDeck(diff);

    if (deck.length === 0){
      deck = buildFreshDeck(diff);
      showToast("üéâ You‚Äôve exhausted all terms in this difficulty. Resetting the deck.", "good");
    }

    const idx = deck.pop();
    return BANK[idx];
  }

  function resetDecks(){
    for (const d of DIFFS){
      buildFreshDeck(d);
    }
    updateRemaining();
    showToast("üßπ Deck reset. Remaining is back to full for this session.", "good");
  }

  // =============================
  // Rendering
  // =============================
  function renderKeyboard(){
    kbdEl.innerHTML = "";
    ALPH.forEach(ch => {
      const d = document.createElement("div");
      d.className = "key";
      d.textContent = ch;
      d.addEventListener("click", () => onGuess(ch, d));
      kbdEl.appendChild(d);
    });
  }

  function renderWord(){
    wordEl.innerHTML = "";
    for (const ch of answer) {
      if (ch === " ") {
        const s = document.createElement("div");
        s.className = "tile space";
        wordEl.appendChild(s);
        continue;
      }
      if (!/[A-Z]/.test(ch)) {
        const p = document.createElement("div");
        p.className = "tile punct";
        p.textContent = ch;
        wordEl.appendChild(p);
        continue;
      }
      const t = document.createElement("div");
      t.className = "tile";
      t.textContent = revealed.has(ch) ? ch : "";
      wordEl.appendChild(t);
    }
  }

  function updateHealth(){
    livesEl.textContent = lives;
    const pct = Math.max(0, lives / MAX_LIVES) * 100;
    fillEl.style.width = pct + "%";

    if (lives >= 5) stateText.textContent = "On Track";
    else if (lives >= 3) stateText.textContent = "At Risk";
    else if (lives >= 1) stateText.textContent = "Critical";
    else stateText.textContent = "Failed";

    if (lives >= 5) fillEl.style.background = "linear-gradient(90deg, rgba(34,197,94,0.95), rgba(16,185,129,0.90))";
    else if (lives >= 3) fillEl.style.background = "linear-gradient(90deg, rgba(245,158,11,0.95), rgba(20,184,166,0.85))";
    else fillEl.style.background = "linear-gradient(90deg, rgba(239,68,68,0.95), rgba(245,158,11,0.85))";
  }

  function updateStats(){
    scoreEl.textContent = String(examActive ? examScore : score);
    solvedEl.textContent = String(examActive ? examSolved : solvedCount);
    streakEl.textContent = String(streak);
    bestStreakEl.textContent = String(bestStreak);
    scoreTagEl.textContent = examActive ? "Exam" : "Practice";
  }

  function disableKeyboard(disabled=true){
    [...kbdEl.querySelectorAll(".key")].forEach(k => {
      if (disabled) k.classList.add("used");
      else k.classList.remove("used");
      k.style.pointerEvents = disabled ? "none" : "auto";
    });
  }

  function isSolved(){
    for (const ch of answer) {
      if (/[A-Z]/.test(ch) && !revealed.has(ch)) return false;
    }
    return true;
  }

  function updateRemaining(){
    const diff = diffSelect.value;
    remainingEl.textContent = String(remainingCount(diff));
    modeDetailEl.textContent = `${examActive ? "Exam" : "Practice"} ‚Ä¢ ${difficultyLabel(diff)}`;
  }

  function setModeUI(){
    modeLabel.textContent = examToggle.checked ? "Exam" : "Practice";
    examProgress.style.display = examToggle.checked ? "inline" : "none";
    btnNext.textContent = examToggle.checked ? (examActive ? "Next round" : "Start exam") : "New word";
    btnHint.disabled = false;

    // Allow difficulty selection anytime BEFORE first guess in the round.
    // In Exam mode, lock difficulty once exam starts (so the 10 rounds are consistent).
    if (examActive){
      diffSelect.disabled = true;
      examToggle.disabled = true;
      btnResetDeck.disabled = true;
    } else {
      examToggle.disabled = false;
      btnResetDeck.disabled = false;
      diffSelect.disabled = (roundInPlay && guessesMade); // key fix
    }

    updateRemaining();
    updateStats();
  }

  // =============================
  // Load bank
  // =============================
  async function loadBank(){
    if (BANK.length) return;

    bankStatusEl.textContent = "Loading bank‚Ä¶";

    try{
      const res = await fetch("./words.json", { cache: "no-store" });
      if (!res.ok) throw new Error("Failed to load words.json (" + res.status + ")");
      const data = await res.json();
      if (!Array.isArray(data) || !data.length) throw new Error("words.json is empty/invalid");

      BANK = data
        .filter(x => x && typeof x.term === "string" && typeof x.hint === "string")
        .map(x => ({
          term: x.term.trim().toUpperCase(),
          hint: x.hint.trim(),
          diff: "medium"
        }));

      // Build difficulty subsets
      subsetIndices.all = [];
      subsetIndices.easy = [];
      subsetIndices.medium = [];
      subsetIndices.hard = [];

      BANK.forEach((item, idx) => {
        const d = classifyDifficulty(item.term);
        item.diff = d;
        subsetIndices.all.push(idx);
        subsetIndices[d].push(idx);
      });

      BANK_SIG = bankSignature();

      // Build fresh decks for this session (so Remaining starts at full)
      for (const d of DIFFS){
        buildFreshDeck(d);
      }

      bankStatusEl.textContent = `Bank: ${BANK.length} terms`;
      updateRemaining();

    } catch (e){
      console.warn(e);
      bankStatusEl.textContent = "Bank load failed (using fallback)";
      BANK = [
        { term: "WORK BREAKDOWN STRUCTURE", hint: "A hierarchical decomposition of project scope into deliverables and work packages (WBS).", diff:"medium" },
        { term: "CRITICAL PATH", hint: "The longest dependent path that sets the minimum project duration.", diff:"easy" },
        { term: "RISK REGISTER", hint: "A document listing identified risks, responses, owners, and status.", diff:"easy" }
      ];
      subsetIndices.all = [0,1,2];
      subsetIndices.easy = [1,2];
      subsetIndices.medium = [0];
      subsetIndices.hard = [];
      BANK_SIG = bankSignature();
      for (const d of DIFFS){ buildFreshDeck(d); }
      updateRemaining();
      showToast("‚ö†Ô∏è words.json could not be loaded. Upload words.json to the same folder as index.html.", "bad");
    }
  }

  // =============================
  // Round flow
  // =============================
  function beginRound(){
    hideToast();
    setHint("");

    lives = MAX_LIVES;
    used = new Set();
    revealed = new Set();
    guessesMade = false;
    roundInPlay = true;

    const diff = diffSelect.value;
    currentPick = drawNextPick(diff);
    answer = currentPick.term;

    renderWord();
    updateHealth();
    renderKeyboard();
    disableKeyboard(false);

    btnHint.disabled = false;
    btnHint.onclick = () => {
      setHint("Hint: " + currentPick.hint);
      btnHint.disabled = true;
    };

    updateRemaining();
    setModeUI();
  }

  function endRoundUI(){
    disableKeyboard(true);
    roundInPlay = false;
    setModeUI();
  }

  function onRoundWin(){
    const bonus = Math.max(0, lives) * 2;
    const gained = 10 + bonus;

    if (examActive){
      examScore += gained;
      examSolved += 1;
      showToast(`‚úÖ Round ${examRound} solved! +${gained} points. Click ‚ÄúNext round‚Äù.`, "good");
    } else {
      score += gained;
      solvedCount += 1;
      streak += 1;
      bestStreak = Math.max(bestStreak, streak);
      localStorage.setItem(LS_BEST_STREAK, String(bestStreak));
      showToast(`‚úÖ Solved! +${gained} points. Click ‚ÄúNew word‚Äù for the next term.`, "good");
    }

    updateStats();
    endRoundUI();
  }

  function onRoundFail(){
    if (examActive){
      examFailed += 1;
      showToast(`‚ùå Round ${examRound} failed. The term was: ${answer}. Click ‚ÄúNext round‚Äù.`, "bad");
    } else {
      streak = 0;
      showToast(`‚ùå Project failed. The term was: ${answer}. Click ‚ÄúNew word‚Äù to try again.`, "bad");
    }
    updateStats();
    endRoundUI();
  }

  function finishExam(){
    // End exam session
    examActive = false;
    examToggle.checked = false;

    const diffName = difficultyLabel(diffSelect.value);
    const summary = `üèÅ Exam complete! Score: ${examScore} ‚Ä¢ Solved: ${examSolved}/${EXAM_ROUNDS} ‚Ä¢ Difficulty: ${diffName}.`;
    showToast(summary + " Use Share to copy a post-ready blurb.", "good");

    setModeUI();
  }

  // =============================
  // Guess logic
  // =============================
  function onGuess(ch, keyEl){
    if (keyEl.classList.contains("used")) return;
    if (used.has(ch)) return;
    used.add(ch);

    // Lock difficulty only AFTER the first guess in the round
    if (!guessesMade){
      guessesMade = true;
      setModeUI();
    }

    const hit = answer.includes(ch);
    if (hit){
      revealed.add(ch);
      keyEl.classList.add("used","good");
      renderWord();

      if (isSolved()){
        onRoundWin();
      }
    } else {
      lives -= 1;
      keyEl.classList.add("used","bad");
      updateHealth();

      if (lives <= 0){
        onRoundFail();
      }
    }
  }

  // =============================
  // Mode actions
  // =============================
  async function startPractice(){
    examActive = false;
    examRound = 0;
    setModeUI();
    beginRound();
  }

  async function startExam(){
    examActive = true;
    examRound = 1;
    examSolved = 0;
    examFailed = 0;
    examScore = 0;

    roundNowEl.textContent = String(examRound);
    setModeUI();
    beginRound();
  }

  // =============================
  // Share
  // =============================
  async function shareResult(){
    const url = window.location.href;
    const diffName = difficultyLabel(diffSelect.value);

    let text = "";
    if (examActive){
      text = `I'm playing PMP + Agile Hangman (Exam mode, ${diffName}). Round ${examRound}/${EXAM_ROUNDS} ‚Ä¢ Score ${examScore} ‚Ä¢ Solved ${examSolved}. Try it: ${url}`;
    } else if (examRound >= EXAM_ROUNDS && (examSolved + examFailed) === EXAM_ROUNDS && (examScore > 0)){
      text = `I just finished a 10-round PMP + Agile Hangman exam (${diffName}). Score: ${examScore} ‚Ä¢ Solved: ${examSolved}/${EXAM_ROUNDS}. Try it: ${url}`;
    } else {
      text = `I'm playing PMP + Agile Hangman (${diffName}). Score: ${score} ‚Ä¢ Best streak: ${bestStreak}. Try it: ${url}`;
    }

    try{
      await navigator.clipboard.writeText(text);
      showToast("üìã Copied to clipboard! Paste it into LinkedIn (or anywhere).", "good");
    } catch {
      window.prompt("Copy this text:", text);
    }
  }

  // =============================
  // Events
  // =============================
  btnNext.addEventListener("click", async () => {
    await loadBank();

    // If a round is in play, require completing it
    const anyKeyEnabled = [...kbdEl.querySelectorAll(".key")].some(k => !k.classList.contains("used") && k.style.pointerEvents !== "none");
    if (roundInPlay && anyKeyEnabled){
      showToast("Finish this round first (solve or run out of guesses).", "bad");
      return;
    }

    if (examToggle.checked){
      if (!examActive){
        await startExam();
        return;
      }

      // exam active: advance rounds
      if (examRound >= EXAM_ROUNDS){
        finishExam();
        return;
      }

      examRound += 1;
      roundNowEl.textContent = String(examRound);
      beginRound();
    } else {
      startPractice();
    }
  });

  btnShare.addEventListener("click", () => shareResult());

  btnResetDeck.addEventListener("click", async () => {
    await loadBank();
    if (examActive){
      showToast("End the exam first before resetting the deck.", "bad");
      return;
    }
    resetDecks();
  });

  diffSelect.addEventListener("change", async () => {
    await loadBank();

    // Only block changing difficulty if the round is already in-play AND user has started guessing
    if (roundInPlay && guessesMade){
      showToast("You can change difficulty after the round ends (or before your first guess).", "bad");
      // revert by forcing UI update
      setModeUI();
      return;
    }

    updateRemaining();
    setModeUI();
  });

  examToggle.addEventListener("change", () => {
    if (examActive){
      examToggle.checked = true;
      showToast("Finish the exam run first (10 rounds).", "bad");
      return;
    }
    setModeUI();
  });

  window.addEventListener("keydown", (e)=>{
    const k = String(e.key || "").toUpperCase();
    if (k.length === 1 && k >= "A" && k <= "Z") {
      const keyDiv = [...kbdEl.querySelectorAll(".key")].find(x => x.textContent === k);
      if (keyDiv && !keyDiv.classList.contains("used") && keyDiv.style.pointerEvents !== "none") onGuess(k, keyDiv);
    }
    if (e.key === "Enter") {
      btnNext.click();
    }
  });

  // =============================
  // Boot
  // =============================
  (async function init(){
    await loadBank();
    setModeUI();
    updateStats();
    renderKeyboard();
    disableKeyboard(true);
    // start immediately in practice with first word
    startPractice();
  })();
</script>
</body>
</html>
